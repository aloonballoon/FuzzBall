/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src.js":
/*!****************!*\
  !*** ./src.js ***!
  \****************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\nconst canvas = document.querySelector('canvas');\nconst context = canvas.getContext('2d');\ncanvas.style.cursor = \"ns-resize\";\n\n\nconst mouse = {\n  x: undefined,\n  y: undefined,\n  direction: 'vertical'\n};\n\nlet soundOn = true;\nlet lightsaberSound;\nlet clashLightsaberSound;\nlet humLightsaberSound;\nlet duelOfTheFates;\n\nlet particles;\n\nlet gridHeight = 30;\nlet gridColCount = 30;\nlet gridRowCount = 20;\n\nlet lineId = 0;\nlet pairId = 0;\n\ncanvas.height = gridHeight * gridRowCount;\ncanvas.width = gridHeight * gridColCount;\n\nlet gridId = 0;\nlet grid = [];\n\n\ncanvas.addEventListener('click', (event) => {\n  let x = event.offsetX;\n  let y = event.offsetY;\n\n  mouse.x = x;\n  mouse.y = y;\n});\n\ncanvas.addEventListener('contextmenu', (event) => {\n    event.preventDefault();\n    switch (mouse.direction) {\n      case 'vertical':\n        mouse.direction = 'horizontal';\n        canvas.style.cursor = \"ew-resize\";\n        break;\n      case 'horizontal':\n        mouse.direction = 'vertical';\n        canvas.style.cursor = \"ns-resize\";\n        break;\n      default:\n        return null;\n    }\n    return false;\n}, false);\n\nclass Sound {\n  constructor(src) {\n    this.sound = document.createElement(\"audio\");\n    this.sound.src = src;\n    this.sound.setAttribute(\"preload\", \"auto\");\n    this.sound.setAttribute(\"controls\", \"none\");\n    this.sound.style.display = \"none\";\n    document.body.appendChild(this.sound);\n  }\n  stop() {\n    if (soundOn) {\n      this.sound.pause();\n      this.currentTime = 0;\n    }\n  }\n  play() {\n    if (soundOn) {\n      this.sound.play();\n    }\n  }\n}\n\nlightsaberSound = new Sound(\"mp3/coolsaber.mp3\");\nclashLightsaberSound = new Sound(\"mp3/clash.mp3\");\nhumLightsaberSound = new Sound(\"mp3/humsaber.mp3\");\nduelOfTheFates = new Sound(\"mp3/duel.mp3\");\n\n\n\nconst createLines = () => {\n  let box;\n  for (let c = 0; c < gridColCount ; c++) {\n    for (let r = 0; r < gridRowCount; r++) {\n      box = grid[c][r];\n      if (mouse.direction === 'vertical' && box.gridStatus === 0) {\n        if (mouse.x > box.gridX && mouse.x < box.gridHeight + box.gridX && mouse.y > box.gridY && mouse.y < box.gridY + box.gridHeight) {\n          const line1 = new Line(box.gridX, box.gridY, mouse.direction, box.gridHeight, \"bottom\", pairId, \"moving\", lineId);\n          lines.push(line1);\n          lineId += 1;\n          const line2 = new Line(box.gridX, box.gridY, mouse.direction, box.gridHeight, \"top\", pairId, \"moving\", lineId);\n          lines.push(line2);\n          lineId += 1;\n          pairId += 1;\n          lightsaberSound.play();\n\n        }\n      } else if (mouse.direction === 'horizontal') {\n          if (mouse.x > box.gridX && mouse.x < box.gridHeight + box.gridX && mouse.y > box.gridY && mouse.y < box.gridY + box.gridHeight) {\n            const line1 = new Line(box.gridX, box.gridY, mouse.direction, box.gridHeight, \"right\", pairId, \"moving\", lineId);\n            lines.push(line1);\n            lineId += 1;\n            const line2 = new Line(box.gridX, box.gridY, mouse.direction, box.gridHeight, \"left\", pairId, \"moving\", lineId);\n            lines.push(line2);\n            pairId += 1;\n            lineId += 1;\n            lightsaberSound.play();\n          }\n        }\n      }\n    }\n};\n\nlet lines = [];\n\nconst handleClick = (event) => {\n  let clickX = event.x;\n  let clickY = event.y;\n\n  clickX -= canvas.offsetLeft;\n  clickY -= canvas.offsetTop;\n  mouse.x = clickX;\n  mouse.y = clickY;\n  if (checkLineMoving()) {\n    createLines();\n  }\n};\n\nconst checkLineMoving = () => {\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].status === \"moving\") {\n      return false;\n    }\n  }\n  return true;\n};\n\n\nconst getRandomColor = () => {\n  const letters = '0123456789ABCDEF';\n  let color = '#';\n  for (let i = 0; i < 6; i++) {\n    color += letters[Math.floor(Math.random() * 16)];\n  }\n  return color;\n};\n\nconst circleBlackOut = () => {\n  gridArrForBlackOut = [];\n  let box;\n  for (let i = 0; i < particles.length; i++) {\n    gridArrForBlackOut.push(particles[i].getGridLocation());\n    box = gridArrForBlackOut[i];\n    box.bfs();\n  }\n  for (let c = 0; c < gridColCount; c++) {\n    for (let r = 0; r < gridRowCount; r++) {\n      if (grid[c][r].gridStatus === 0) {\n        grid[c][r].gridStatus = 1;\n      } else if (grid[c][r].gridStatus === 2) {\n        grid[c][r].gridStatus = 0;\n        grid[c][r].visited = false;\n      }\n    }\n  }\n\n};\n\n\nclass Grid {\n  constructor(gridHeight, gridX, gridY, gridId, gridStatus) {\n    this.gridHeight = gridHeight;\n    this.gridX = gridX;\n    this.gridY = gridY;\n    this.gridId = gridId;\n    this.gridStatus = gridStatus;\n    this.neighbors = {\n      top: null,\n      bottom: null,\n      right: null,\n      left: null\n    };\n    this.visited = false;\n    this.ballPresent = undefined;\n  }\n\n  drawEmpty() {\n    context.beginPath();\n    context.rect(this.gridX, this.gridY, this.gridHeight, this.gridHeight);\n    context.strokeStyle = \"black\";\n    context.stroke();\n    context.closePath();\n  }\n\n  drawFull() {\n    context.beginPath();\n    context.rect(this.gridX, this.gridY, this.gridHeight, this.gridHeight);\n    context.strokeStyle = \"black\";\n    context.fillStyle = \"black\";\n    context.fill();\n    context.stroke();\n    context.closePath();\n  }\n\n  bfs() {\n\n    let currentGrid = this;\n    let neighbors = [];\n    let queue = [];\n\n    queue.push(currentGrid);\n\n    while (queue.length !== 0) {\n      currentGrid = queue.shift();\n      currentGrid.visited = true;\n      currentGrid.gridStatus = 2;\n\n      neighbors = Object.values(currentGrid.neighbors).filter(Boolean);\n\n      for (let i = 0; i < neighbors.length; i++) {\n        if (neighbors[i].visited === false && neighbors[i].gridStatus !== 1 && !queue.includes(neighbors[i])) {\n          queue.push(neighbors[i]);\n\n        }\n      }\n    }\n  }\n}\n\nconst initiateGrid = () => {\n  for (let c = 0; c < gridColCount; c++) {\n    grid[c] = [];\n    for (let r = 0; r < gridRowCount; r++) {\n      grid[c][r] = new Grid(0, 0, 0, gridId, 0);\n      gridId += 1;\n    }\n  }\n};\n\n\n\nconst drawGrid = () => {\n  claimedArea = 0;\n  for (let c = 0; c < gridColCount; c++) {\n    for (let r = 0; r < gridRowCount; r++) {\n        let box = grid[c][r];\n        let gridX = (c * gridHeight);\n        let gridY = (r * gridHeight);\n\n        box.gridHeight = gridHeight;\n        box.gridX = gridX;\n        box.gridY = gridY;\n\n        // handle \"edge\" cases for checking properties of undefined\n        if (typeof grid[c + 1] === \"undefined\") {\n          grid[c + 1] = {};\n        } else if (typeof grid[c - 1] === \"undefined\") {\n          grid[c - 1] = {};\n        }\n\n        box.neighbors.right = grid[c + 1][r];\n        box.neighbors.left = grid[c - 1][r];\n        box.neighbors.bottom = grid[c][r + 1];\n        box.neighbors.top = grid[c][r - 1];\n\n        if (box.gridStatus === 0) {\n          box.drawEmpty();\n        } else if (grid[c][r].gridStatus === 1) {\n          box.drawFull();\n          claimedArea += 1;\n        }\n\n    }\n  }\n};\n\nclass Line {\n  constructor(lineX, lineY, direction, gridHeight, side, pairId, status, lineId) {\n    this.direction = direction;\n    this.lineX = lineX;\n    this.lineY = lineY;\n    this.gridHeight = gridHeight;\n    this.width = this.gridHeight;\n    this.height = this.gridHeight;\n    this.dW = 5;\n    this.dH = 5;\n    this.side = side;\n    this.blue = 'rgb(0,0,255, 0.8)';\n    this.red = 'rgb(255,0,0, 0.8)';\n    this.black = 'rgb(0, 0, 0, 0.8)';\n    this.pairId = pairId;\n    this.status = status;\n    this.lineId = lineId;\n    this.searchInitiate = \"incomplete\";\n    this.complete = \"incomplete\";\n  }\n\n\n  bottomLineToLineDistance(otherLine) {\n    let xTouching;\n    let yTouching;\n\n    yTouching = this.lineY + this.height === otherLine.lineY;\n    xTouching = ((this.lineX > otherLine.lineX) && (this.lineX < (otherLine.lineX + otherLine.width))) || ((this.lineX < otherLine.lineX) && (this.lineX >= (otherLine.lineX + otherLine.width))) || this.lineX === otherLine.lineX;\n\n    if (xTouching && yTouching) {\n      return true;\n    }\n  }\n\n  topLineToLineDistance(otherLine) {\n    let xTouching;\n    let yTouching;\n\n    yTouching = this.lineY + this.height === otherLine.lineY + otherLine.gridHeight;\n    xTouching = ((this.lineX > otherLine.lineX) && (this.lineX < (otherLine.lineX + otherLine.width))) || ((this.lineX < otherLine.lineX) && (this.lineX >= (otherLine.lineX + otherLine.width))) || this.lineX === otherLine.lineX;\n\n    if (xTouching && yTouching) {\n      return true;\n    }\n  }\n\n  rightLineToLineDistance(otherLine) {\n    let xTouching;\n    let yTouching;\n\n    xTouching = this.lineX + this.width === otherLine.lineX;\n    yTouching = ((this.lineY > otherLine.lineY) && (this.lineY < (otherLine.lineY + otherLine.height))) || ((this.lineY < otherLine.lineY) && (this.lineY >= (otherLine.lineY + otherLine.height))) || this.lineY === otherLine.lineY;\n\n    if (xTouching && yTouching) {\n      return true;\n    }\n  }\n\n  leftLineToLineDistance(otherLine) {\n    let xTouching;\n    let yTouching;\n\n    xTouching = this.lineX + this.width === otherLine.lineX + otherLine.gridHeight;\n    yTouching = ((this.lineY > otherLine.lineY) && (this.lineY < (otherLine.lineY + otherLine.height))) || ((this.lineY < otherLine.lineY) && (this.lineY >= (otherLine.lineY + otherLine.height))) || this.lineY === otherLine.lineY;\n\n    if (xTouching && yTouching) {\n      return true;\n    }\n  }\n\n\n  checkLineCollision() {\n    for (let i = 0; i < lines.length; i++) {\n      if (this.pairId === lines[i].pairId) {\n        continue;\n      }\n      if (this.side === \"right\") {\n        if (this.rightLineToLineDistance(lines[i])) {\n          this.status = \"stopped\";\n        }\n      } else if (this.side === \"left\") {\n        if (this.leftLineToLineDistance(lines[i])) {\n          this.status = \"stopped\";\n        }\n      } else if (this.side === \"top\") {\n        if (this.topLineToLineDistance(lines[i])) {\n          this.status = \"stopped\";\n        }\n      } else if (this.side === \"bottom\") {\n        if (this.bottomLineToLineDistance(lines[i])) {\n          this.status = \"stopped\";\n        }\n      }\n    }\n  }\n\n  checkWallCollision() {\n    if (this.side === \"right\") {\n      if (this.lineX + this.width === canvas.width) {\n        this.status = \"stopped\";\n      }\n    } else if (this.side === \"left\") {\n        if (this.lineX + this.width < 0) {\n          this.status = \"stopped\";\n        }\n    } else if (this.side === \"top\") {\n        if (this.lineY + this.height < 0) {\n          this.status = \"stopped\";\n        }\n    }\n      else if (this.side === \"bottom\") {\n        if (this.lineY + this.height === canvas.height) {\n          this.status = \"stopped\";\n        }\n      }\n  }\n\n\n\n  updateGrid() {\n    for (let i = 0; i < lines.length; i++) {\n\n      if (this.status === \"stopped\" && lines[i].pairId === this.pairId && lines[i].status === \"stopped\" && lines[i].lineId !== this.lineId) {\n        let line = this;\n        let box;\n\n        for (let c = 0; c < gridColCount; c++) {\n          for (let r = 0; r < gridRowCount; r++) {\n            box = grid[c][r];\n            //bottom\n            if (box.gridX === line.lineX && box.gridY === line.lineY) {\n              box.gridStatus = 1;\n            }\n            if (box.gridX === line.lineX && box.gridY < line.lineY && box.gridY >= line.lineY + line.height) {\n              box.gridStatus = 1;\n              line.complete = \"complete\";\n            } else if (box.gridX === line.lineX && box.gridY > line.lineY && box.gridY < line.lineY + line.height) {\n              box.gridStatus = 1;\n              line.complete = \"complete\";\n            } else if (box.gridY === line.lineY && box.gridX < line.lineX && box.gridX > line.lineX + line.width - line.gridHeight) {\n              box.gridStatus = 1;\n              line.complete = \"complete\";\n            } else if (box.gridY === line.lineY && box.gridX > line.lineX && box.gridX < line.lineX + line.width) {\n              box.gridStatus = 1;\n              line.complete = \"complete\";\n            }\n          }\n        }\n        this.complete = \"complete\";\n        if (this.searchInitiate === \"incomplete\") {\n          if (lines[i].complete === \"complete\") {\n            circleBlackOut();\n            this.searchInitiate = \"complete\";\n            lines[i].searchInitiate = \"complete\";\n          }\n        }\n      }\n    }\n  }\n\n\n  update(){\n    this.checkWallCollision();\n    this.checkLineCollision();\n    this.updateGrid();\n    this.growLine();\n  }\n\n  growLine() {\n    if (this.direction === 'horizontal') {\n\n      if (this.side === 'right' && this.status === \"moving\") {\n          context.beginPath();\n          context.fillStyle = this.red;\n          context.fillRect(this.lineX, this.lineY, this.width, this.height);\n          this.width += this.dW;\n\n      } else if (this.side === 'left' && this.status === \"moving\") {\n          context.beginPath();\n          context.fillStyle = this.blue;\n          context.fillRect(this.lineX, this.lineY, this.width, this.height);\n          this.width -= this.dW;\n\n      } else if (this.status === \"stopped\") {\n        context.beginPath();\n        context.fillStyle = this.black;\n        context.fillRect(this.lineX, this.lineY, this.width, this.height);\n      }\n    } else if (this.direction === 'vertical') {\n\n      if (this.side === 'bottom' && this.status === \"moving\") {\n        context.beginPath();\n        context.fillStyle = this.red;\n        context.fillRect(this.lineX, this.lineY, this.width, this.height);\n        this.height += this.dH;\n\n      } else if (this.side === 'top' && this.status === \"moving\") {\n        context.beginPath();\n        context.fillStyle = this.blue;\n        context.fillRect(this.lineX, this.lineY, this.width, this.height);\n        this.height -= this.dH;\n\n      } else if (this.status === \"stopped\") {\n        context.beginPath();\n        context.fillStyle = this.black;\n        context.fillRect(this.lineX, this.lineY, this.width, this.height);\n      }\n    }\n  }\n\n\n\n}\n\nconst resolveCollision = (particle1, particle2) => {\n    const deltaVelocityX = particle1.velocity.x - particle2.velocity.x;\n    const deltaVelocityY = particle1.velocity.y - particle2.velocity.y;\n\n    const xDist = particle2.x - particle1.x;\n    const yDist = particle2.y - particle1.y;\n\n\n    if (deltaVelocityX * xDist + deltaVelocityY * yDist >= 0) {\n\n\n        const angle = -Math.atan2(particle2.y - particle1.y, particle2.x - particle1.x);\n\n        const m1 = particle1.mass;\n        const m2 = particle2.mass;\n\n        const u1 = rotate(particle1.velocity, angle);\n        const u2 = rotate(particle2.velocity, angle);\n\n        const v1 = { x: u1.x * (m1 - m2) / (m1 + m2) + u2.x * 2 * m2 / (m1 + m2), y: u1.y };\n        const v2 = { x: u2.x * (m1 - m2) / (m1 + m2) + u1.x * 2 * m2 / (m1 + m2), y: u2.y };\n\n        const vFinal1 = rotate(v1, -angle);\n        const vFinal2 = rotate(v2, -angle);\n\n        particle1.velocity.x = vFinal1.x;\n        particle1.velocity.y = vFinal1.y;\n\n        particle2.velocity.x = vFinal2.x;\n        particle2.velocity.y = vFinal2.y;\n    }\n};\n\nconst rotate = (velocity, angle) => {\n    const rotatedVelocities = {\n        x: velocity.x * Math.cos(angle) - velocity.y * Math.sin(angle),\n        y: velocity.x * Math.sin(angle) + velocity.y * Math.cos(angle)\n    };\n\n    return rotatedVelocities;\n};\n\nclass Circle {\n\n  constructor(x, y, dx, dy, radius, color) {\n    this.x = x;\n    this.y = y;\n    this.velocity = {\n      x: dx,\n      y: dy\n    };\n    this.dy = dy;\n    this.radius = radius;\n    this.color = color;\n    this.mass = 1;\n  }\n\n  draw() {\n    context.strokeStyle = \"black\";\n    context.beginPath();\n    context.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);\n    context.fillStyle = this.color;\n    context.fill();\n    context.stroke();\n  }\n\n\n  circleToLineCollision() {\n\n    let line;\n\n    for (let i = 0; i < lines.length; i++) {\n      if (lines.length === 0) {\n        break;\n      }\n      line = lines[i];\n      if (line.direction === \"vertical\") {\n        if (this.x + this.radius > line.lineX && this.x - this.radius < line.lineX + line.width && this.y + this.radius > line.lineY && this.y + this.radius < line.lineY + line.height) {\n          if (line.status === \"stopped\") {\n            this.velocity.x = -this.velocity.x;\n          } else if (line.status === \"moving\") {\n            for (let j = 0; j < lines.length; j++) {\n              if (lines[j].pairId === lines[i].pairId && lines[j].lineId !== lines[i].lineId) {\n                delete lines[i];\n                delete lines[j];\n                lives -= 1;\n                lightsaberSound.stop();\n                clashLightsaberSound.play();\n                lines = lines.filter(Boolean);\n              }\n            }\n            i = 0;\n          }\n        } else if (this.x + this.radius > line.lineX && this.x - this.radius < line.lineX + line.width && this.y + this.radius < line.lineY && this.y + this.radius > line.lineY + line.height) {\n          if (line.status === \"stopped\") {\n            this.velocity.x = -this.velocity.x;\n          }  else if (line.status === \"moving\") {\n            for (let j = 0; j < lines.length; j++) {\n              if (lines[j].pairId === lines[i].pairId && lines[j].lineId !== lines[i].lineId) {\n                delete lines[i];\n                delete lines[j];\n                lives -= 1;\n                lightsaberSound.stop();\n                clashLightsaberSound.play();\n                lines = lines.filter(Boolean);\n              }\n            }\n            i = 0;\n          }\n        }\n      } else if (line.direction === \"horizontal\") {\n          if (this.y + this.radius > line.lineY && this.y - this.radius < line.lineY + line.height && this.x + this.radius > line.lineX && this.x + this.radius < line.lineX + line.width) {\n            if (line.status === \"stopped\") {\n              this.velocity.y = -this.velocity.y;\n            }  else if (line.status === \"moving\") {\n              for (let j = 0; j < lines.length; j++) {\n                if (lines[j].pairId === lines[i].pairId && lines[j].lineId !== lines[i].lineId) {\n                  delete lines[i];\n                  delete lines[j];\n                  lives -= 1;\n                  lightsaberSound.stop();\n                  clashLightsaberSound.play();\n                  lines = lines.filter(Boolean);\n                }\n              }\n              i = 0;\n            }\n          } else if (this.y + this.radius > line.lineY && this.y - this.radius < line.lineY + line.height && this.x + this.radius < line.lineX && this.x + this.radius > line.lineX + line.width) {\n            if (line.status === \"stopped\") {\n              this.velocity.y = -this.velocity.y;\n            }  else if (line.status === \"moving\") {\n              for (let j = 0; j < lines.length; j++) {\n                if (lines[j].pairId === lines[i].pairId && lines[j].lineId !== lines[i].lineId) {\n                  delete lines[i];\n                  delete lines[j];\n                  lives -= 1;\n                  lightsaberSound.stop();\n                  clashLightsaberSound.play();\n                  lines = lines.filter(Boolean);\n                }\n              }\n              i = 0;\n            }\n          }\n      }\n    }\n  }\n\n  getGridLocation() {\n    let gridCol = Math.floor(this.x / gridHeight);\n    let gridRow = Math.floor(this.y / gridHeight);\n    return grid[gridCol][gridRow];\n\n  }\n\n  update(particles) {\n\n    for (let j = 0; j < particles.length; j++) {\n      if (this === particles[j]){\n       continue;\n      }\n      if (getDistance(this.x, this.y, particles[j].x, particles[j].y) - particles[j].radius * 2 < 0) {\n          resolveCollision(this, particles[j]);\n      }\n    }\n\n    if (lines.length !== 0) {\n      this.circleToLineCollision();\n    }\n\n    if (this.x + this.radius > canvas.width || this.x - this.radius < 0) {\n      this.velocity.x = -this.velocity.x;\n    }\n\n    if (this.y + this.radius > canvas.height || this.y - this.radius < 0) {\n      this.velocity.y = -this.velocity.y;\n    }\n\n    this.x += this.velocity.x;\n    this.y += this.velocity.y;\n\n    this.draw();\n  }\n\n }\n\n\n\nconst initiateParticles = () => {\n  particles = [];\n\n  for (let i = 0; i < ballCount; i++) {\n    let color = getRandomColor();\n    let radius = 10;\n    let x = Math.random() * (canvas.width - radius * 2) + radius;\n    let y = Math.random() * (canvas.height - radius * 2) + radius;\n    let dx = (Math.random() - 0.5) * 12;\n    let dy = (Math.random() - 0.5) * 12;\n\n    if (i !== 0) {\n      for (let j = 0; j < particles.length; j++) {\n        if (getDistance(x, y, particles[j].x, particles[j].y) -radius * 2 < 0) {\n          x = Math.random() * (canvas.width - radius * 2) + radius;\n          y = Math.random() * (canvas.height - radius * 2) + radius;\n          j = -1;\n        }\n      }\n    }\n  particles.push(new Circle(x, y, dx, dy, radius, color));\n\n  }\n};\n\n\nconst getDistance = (x1,y1, x2, y2) => {\n  let xDistance = x2 - x1;\n  let yDistance = y2 - y1;\n\n  return Math.sqrt(Math.pow(xDistance, 2) + Math.pow(yDistance, 2));\n};\n\nlet startingBallCount = 3;\nlet level = 1;\nlet ballCount;\nballCount = startingBallCount;\nlet claimedArea = 0;\nlet totalArea = gridColCount * gridRowCount;\nlet lives = 5;\nlet targetArea = 76;\nlet percentArea;\nlet advancedLevel = false;\nlet nextLevelWaiting = true;\nlet nextLevelFrame;\nlet animateFrame;\nlet nextLevelScreenOn = true;\nlet nextLevelTimeout;\nlet restartListener;\nlet restartable = false;\nlet playEndOfGameMusic = true;\n\nconst newGameResetValues = () => {\n  level = 1;\n  startingBallCount = 3;\n  ballCount = startingBallCount;\n  claimedArea = 0;\n  lives = 5;\n  targetArea = 76;\n  advancedLevel = false;\n  nextLevelWaiting = true;\n  nextLevelScreenOn = true;\n  restartable = false;\n  lines = [];\n  particles = [];\n  grid = [];\n  duelOfTheFates = new Sound(\"mp3/duel.mp3\");\n  playEndOfGameMusic = true;\n};\n\nconst game = () => {\n  if (advancedLevel === false) {\n    if (targetArea > 60) {\n      targetArea = targetArea - 1;\n      advancedLevel = true;\n    }\n  }\n  if (percentArea >= targetArea) {\n    nextLevelScreenOn = false;\n    endLevel();\n    drawNextLevelScreen();\n  }\n  if (lives <= 0) {\n    gameOver();\n  }\n};\n\nconst stopGameOverMusic = () => {\n  duelOfTheFates = false;\n};\n\nconst gameOver = () => {\n  if (playEndOfGameMusic === true) {\n    duelOfTheFates.play();\n  }\n  playEndOfGameMusic = false;\n  blackScreen();\n  gameOverText();\n  restartText();\n  restartable = true;\n  restartListener = window.addEventListener(\"keydown\", (event) => {\n    if (event.key === \"Enter\") {\n      if (restartable === true) {\n        duelOfTheFates.stop();\n        restartGame();\n      }\n    }\n  });\n};\n\nconst restartGame = () => {\n  cancelAnimationFrame(animateFrame);\n  newGameResetValues();\n  initiateGame();\n};\n\nconst gameOverText = () => {\n  context.font=\"75px alien\";\n  context.fillStyle = \"white\";\n  context.fillText(`GAME OVER`, 225, 200);\n};\n\nconst restartText = () => {\n  context.font=\"50px alien\";\n  context.fillStyle = \"white\";\n  context.fillText(`PRESS ENTER TO RESTART`, 115, 400);\n};\n\nconst endLevel = () => {\n  cancelAnimationFrame(animateFrame);\n};\n\nconst drawNextLevelScreen = () => {\n  let nextLevelFrame = requestAnimationFrame(drawNextLevelScreen);\n  blackScreen();\n  levelCompleteText();\n  nextLevelText();\n  if (nextLevelScreenOn === false) {\n    nextLevelTimeout = setTimeout(nextLevel, 2000);\n    nextLevelScreenOn = true;\n  }\n};\n\nconst levelCompleteText = () => {\n  context.font=\"75px alien\";\n  context.fillStyle = \"white\";\n  context.fillText(`LEVEL COMPLETE`, 125, 200);\n};\n\nconst nextLevelText = () => {\n  context.font=\"75px alien\";\n  context.fillStyle = \"white\";\n  context.fillText(`NEXT LEVEL: ${level + 1}`, 150, 400);\n};\n\n\nconst blackScreen = () => {\n  context.beginPath();\n  context.rect(0, 0, canvas.width, canvas.width);\n  context.strokeStyle = \"black\";\n  context.fillStyle = \"black\";\n  context.fill();\n  context.stroke();\n  context.closePath();\n};\n\nconst calculateArea = () => {\n  percentArea =  Math.floor(claimedArea / totalArea * 100);\n};\n\nconst nextLevel = () => {\n  level += 1;\n  ballCount += 1;\n  claimedArea = 0;\n  lives += 1;\n  advancedLevel = false;\n  lines = [];\n  particles = [];\n  grid = [];\n  cancelAnimationFrame(nextLevelFrame);\n  initiateGame();\n};\n\nconst initiateGame = () => {\n  initiateGrid();\n  initiateParticles();\n  animate();\n};\n\n\nconst drawParticles = () => {\n  for (let i = 0; i < particles.length; i++) {\n    particles[i].update(particles);\n  }\n};\n\nconst drawLines = () => {\n  for (let i = 0; i < lines.length; i++) {\n    lines[i].update();\n  }\n};\n\ncanvas.addEventListener('click', handleClick);\n\nconst drawStats = () => {\n  drawClaimedArea();\n  drawTargetArea();\n  drawLives();\n  drawLevels();\n};\n\nconst updateStats = () => {\n  $(\"#lives-div\").text(`LIVES: ${lives}`);\n  $(\"#claimed-percent-div\").text(`CLAIMED PERCENT: ${percentArea}`);\n  $(\"#target-percent-div\").text(`TARGET PERCENT: ${targetArea}`);\n  $(\"#level-div\").text(`LEVEL: ${level}`);\n};\n\nconst animate = () => {\n    animateFrame = requestAnimationFrame(animate);\n    context.clearRect(0, 0, innerWidth, innerHeight);\n    drawGrid();\n    drawParticles();\n    calculateArea();\n    drawLines();\n    updateStats();\n    game();\n  };\n\n  initiateGame();\n\n\n//# sourceURL=webpack:///./src.js?");

/***/ })

/******/ });